name: ðŸš€ Deploy to Google Cloud

on:
  pull_request:
    types: [closed]
    branches: [staging, main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force-deploy:
        description: 'Force deploy (skip security gate)'
        required: false
        default: false
        type: boolean

# Prevent concurrent deployments to the same environment
concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'
  GCP_REGION: 'us-central1'
  ARTIFACT_REGISTRY: 'devsecops-repo'
  GKE_CLUSTER: 'sb-cluster'

jobs:
  # ================================================
  # DETERMINE DEPLOYMENT ENVIRONMENT
  # ================================================
  determine-environment:
    name: ðŸŽ¯ Determine Environment
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-deploy: ${{ steps.env.outputs.should-deploy }}
      security-gate-required: ${{ steps.env.outputs.security-gate-required }}
      
    steps:
    - name: ðŸŽ¯ Determine Target Environment
      id: env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          ENVIRONMENT="${{ inputs.environment }}"
          SHOULD_DEPLOY="true"
        else
          case "${{ github.base_ref }}" in
            "staging")
              ENVIRONMENT="staging"
              SHOULD_DEPLOY="true"
              ;;
            "main")
              ENVIRONMENT="production"
              SHOULD_DEPLOY="true"
              ;;
            *)
              ENVIRONMENT="development"
              SHOULD_DEPLOY="false"
              ;;
          esac
        fi
        
        # Determine if security gate is required
        if [ "$ENVIRONMENT" = "production" ] && [ "${{ inputs.force-deploy }}" != "true" ]; then
          SECURITY_GATE_REQUIRED="true"
        else
          SECURITY_GATE_REQUIRED="false"
        fi
        
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        echo "security-gate-required=$SECURITY_GATE_REQUIRED" >> $GITHUB_OUTPUT
        
        echo "ðŸŽ¯ Environment Configuration:"
        echo "  Environment: $ENVIRONMENT"
        echo "  Should Deploy: $SHOULD_DEPLOY"
        echo "  Security Gate Required: $SECURITY_GATE_REQUIRED"

  # ================================================
  # SECURITY GATE CHECK
  # ================================================
  security-gate:
    name: ðŸ›¡ï¸ Security Gate Check
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.should-deploy == 'true' && needs.determine-environment.outputs.security-gate-required == 'true'
    outputs:
      security-passed: ${{ steps.check.outputs.security-passed }}
      
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ðŸ” Check Latest Security Scan
      id: check
      run: |
        # Get the latest security scan workflow run
        LATEST_RUN=$(gh run list --workflow="security-scan.yml" --branch="${{ github.ref_name }}" --limit=1 --json status,conclusion,createdAt --jq '.[0]')
        
        if [ "$LATEST_RUN" = "null" ] || [ -z "$LATEST_RUN" ]; then
          echo "âŒ No security scan found for this branch"
          echo "security-passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        STATUS=$(echo "$LATEST_RUN" | jq -r '.status')
        CONCLUSION=$(echo "$LATEST_RUN" | jq -r '.conclusion')
        CREATED_AT=$(echo "$LATEST_RUN" | jq -r '.createdAt')
        
        echo "ðŸ“Š Latest Security Scan:"
        echo "  Status: $STATUS"
        echo "  Conclusion: $CONCLUSION"
        echo "  Created: $CREATED_AT"
        
        # Check if security scan passed
        if [ "$STATUS" = "completed" ] && [ "$CONCLUSION" = "success" ]; then
          echo "âœ… Security gate passed"
          echo "security-passed=true" >> $GITHUB_OUTPUT
        else
          echo "âŒ Security gate failed - Status: $STATUS, Conclusion: $CONCLUSION"
          echo "security-passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ================================================
  # BUILD AND PUSH IMAGES
  # ================================================
  build-and-push:
    name: ðŸ—ï¸ Build & Push Images
    runs-on: ubuntu-latest
    needs: [determine-environment, security-gate]
    if: always() && needs.determine-environment.outputs.should-deploy == 'true' && (needs.security-gate.result == 'success' || needs.security-gate.result == 'skipped')
    outputs:
      images-built: ${{ steps.build.outputs.images-built }}
      
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ðŸŸ¨ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ðŸ“¦ Install Dependencies
      run: |
        # Install Node.js dependencies
        if [ -f "package.json" ]; then
          npm ci
        fi
        
        # Install Python dependencies
        if [ -f "requirements.txt" ]; then
          pip install -r requirements.txt
        fi

    - name: ðŸ§ª Run Tests
      run: |
        echo "ðŸ§ª Running tests before deployment..."
        
        # Run Node.js tests
        if [ -f "package.json" ] && npm run test --dry-run 2>/dev/null; then
          npm run test
        fi
        
        # Run Python tests
        if [ -f "requirements.txt" ] && command -v pytest >/dev/null 2>&1; then
          pytest || true
        fi

    - name: ðŸ” Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GOOGLE_CREDENTIALS }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}

    - name: ðŸ³ Configure Docker for GCR
      run: |
        gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

    - name: ðŸ—ï¸ Build and Push Container Images
      id: build
      run: |
        IMAGES_BUILT=""
        
        # Find all Dockerfiles and build images
        for dockerfile in $(find . -name "Dockerfile*" -not -path "./.git/*"); do
          dir=$(dirname "$dockerfile")
          project_name=$(basename "$dir")
          
          # Skip if directory name starts with '.'
          if [[ "$project_name" == .* ]]; then
            continue
          fi
          
          echo "ðŸ—ï¸ Building image for: $project_name"
          
          # Determine image tag
          if [ "${{ needs.determine-environment.outputs.environment }}" = "production" ]; then
            IMAGE_TAG="latest"
          else
            IMAGE_TAG="${{ needs.determine-environment.outputs.environment }}"
          fi
          
          IMAGE_NAME="${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/$project_name:$IMAGE_TAG"
          
          # Build image
          docker build -t "$IMAGE_NAME" "$dir"
          
          # Push image
          docker push "$IMAGE_NAME"
          
          echo "âœ… Image pushed: $IMAGE_NAME" 
          IMAGES_BUILT="${IMAGES_BUILT}${project_name}:$IMAGE_TAG,"
        done
        
        # Remove trailing comma
        IMAGES_BUILT=$(echo "$IMAGES_BUILT" | sed 's/,$//')
        echo "images-built=$IMAGES_BUILT" >> $GITHUB_OUTPUT
        
        echo "ðŸ“¦ Images built and pushed:"
        echo "$IMAGES_BUILT" | tr ',' '\n' | sed 's/^/  - /'

  # ================================================
  # DEPLOY TO GOOGLE CLOUD
  # ================================================
  deploy:
    name: ðŸš€ Deploy to GCP
    runs-on: ubuntu-latest
    needs: [determine-environment, security-gate, build-and-push]
    if: always() && needs.build-and-push.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      deployment-url: ${{ steps.deploy.outputs.deployment-url }}
      deployment-status: ${{ steps.deploy.outputs.deployment-status }}
      
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ðŸ” Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GOOGLE_CREDENTIALS }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}

    - name: â˜¸ï¸ Setup GKE kubectl
      uses: google-github-actions/get-gke-credentials@v2
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GCP_REGION }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}

    - name: ðŸ“‹ Update Kubernetes Manifests
      run: |
        ENV="${{ needs.determine-environment.outputs.environment }}"
        
        # Create namespace if it doesn't exist
        kubectl create namespace "$ENV" --dry-run=client -o yaml | kubectl apply -f -
        
        # Update Kubernetes manifests with environment-specific values
        if [ -d "k8s/$ENV" ]; then
          echo "ðŸ“‹ Updating manifests for environment: $ENV"
          
          # Replace placeholders in Kubernetes manifests
          find "k8s/$ENV" -name "*.yaml" -o -name "*.yml" | while read -r file; do
            echo "ðŸ“ Processing: $file"
            
            # Replace common placeholders
            sed -i "s/{{ENVIRONMENT}}/$ENV/g" "$file"
            sed -i "s/{{GCP_PROJECT_ID}}/${{ secrets.GCP_PROJECT_ID }}/g" "$file"
            sed -i "s/{{GCP_REGION}}/${{ env.GCP_REGION }}/g" "$file"
            sed -i "s/{{ARTIFACT_REGISTRY}}/${{ env.ARTIFACT_REGISTRY }}/g" "$file"
            
            # Set image tags based on environment
            if [ "$ENV" = "production" ]; then
              sed -i "s/{{IMAGE_TAG}}/latest/g" "$file"
            else
              sed -i "s/{{IMAGE_TAG}}/$ENV/g" "$file"
            fi
            
            # Set resource limits based on environment
            case "$ENV" in
              "staging")
                sed -i "s/{{CPU_LIMIT}}/500m/g" "$file"
                sed -i "s/{{MEMORY_LIMIT}}/512Mi/g" "$file"
                sed -i "s/{{REPLICAS}}/2/g" "$file"
                ;;
              "production")
                sed -i "s/{{CPU_LIMIT}}/1000m/g" "$file"
                sed -i "s/{{MEMORY_LIMIT}}/1Gi/g" "$file"
                sed -i "s/{{REPLICAS}}/3/g" "$file"
                ;;
            esac
          done
        else
          echo "âš ï¸ No Kubernetes manifests found for environment: $ENV"
          echo "Creating basic deployment manifest..."
          
          mkdir -p "k8s/$ENV"
          cat > "k8s/$ENV/deployment.yaml" << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: devsecops-app
          namespace: $ENV
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: devsecops-app
          template:
            metadata:
              labels:
                app: devsecops-app
            spec:
              containers:
              - name: app
                image: ${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/react-app:$ENV
                ports:
                - containerPort: 3000
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: devsecops-service
          namespace: $ENV
        spec:
          selector:
            app: devsecops-app
          ports:
          - port: 80
            targetPort: 3000
          type: LoadBalancer
        EOF
        fi

    - name: ðŸš€ Deploy to Kubernetes
      id: deploy
      run: |
        ENV="${{ needs.determine-environment.outputs.environment }}"
        
        echo "ðŸš€ Deploying to environment: $ENV"
        
        # Apply Kubernetes manifests
        if [ -d "k8s/$ENV" ]; then
          kubectl apply -f "k8s/$ENV/" --recursive
          
          # Wait for deployment to be ready
          echo "â³ Waiting for deployment to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment --all -n "$ENV"
          
          # Get service external IP
          echo "ðŸŒ Getting service external IP..."
          EXTERNAL_IP=""
          for i in {1..10}; do
            EXTERNAL_IP=$(kubectl get service -n "$ENV" -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
              break
            fi
            echo "  Waiting for external IP... (attempt $i/10)"
            sleep 30
          done
          
          if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
            DEPLOYMENT_URL="http://$EXTERNAL_IP"
            echo "âœ… Deployment successful!"
            echo "ðŸŒ Application URL: $DEPLOYMENT_URL"
            echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
            echo "deployment-status=success" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Deployment completed but external IP not available yet"
            echo "deployment-url=pending" >> $GITHUB_OUTPUT
            echo "deployment-status=pending" >> $GITHUB_OUTPUT
          fi
          
          # Show deployment status
          echo "ðŸ“Š Deployment Status:"
          kubectl get pods,services,deployments -n "$ENV"
          
        else
          echo "âŒ No Kubernetes manifests found to deploy"
          echo "deployment-status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: ðŸ§ª Post-Deployment Health Check
      if: steps.deploy.outputs.deployment-url != 'pending'
      run: |
        DEPLOYMENT_URL="${{ steps.deploy.outputs.deployment-url }}"
        
        if [ "$DEPLOYMENT_URL" != "pending" ] && [ -n "$DEPLOYMENT_URL" ]; then
          echo "ðŸ” Running health check on: $DEPLOYMENT_URL"
          
          # Wait a bit for the application to fully start
          sleep 30
          
          # Simple health check
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOYMENT_URL" || echo "000")
          
          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
            echo "âœ… Health check passed - HTTP $HTTP_STATUS"
          else
            echo "âš ï¸ Health check warning - HTTP $HTTP_STATUS"
            echo "Application may still be starting up..."
          fi
        else
          echo "â­ï¸ Skipping health check - URL not available yet"
        fi

  # ================================================
  # DEPLOYMENT SUMMARY & NOTIFICATION
  # ================================================
  notify:
    name: ðŸ”” Deployment Notification
    runs-on: ubuntu-latest
    needs: [determine-environment, security-gate, build-and-push, deploy]
    if: always() && needs.determine-environment.outputs.should-deploy == 'true'
    
    steps:
    - name: ðŸ“Š Generate Deployment Summary
      run: |
        cat > deployment-summary.md << 'EOF'
        # ðŸš€ Deployment Summary
        
        **Environment:** ${{ needs.determine-environment.outputs.environment }}
        **Branch:** ${{ github.ref_name }}
        **Commit:** ${{ github.sha }}
        **Triggered by:** ${{ github.actor }}
        **Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
        
        ## ðŸ“Š Results
        - **Security Gate:** ${{ needs.security-gate.result == 'success' && 'âœ… PASSED' || needs.security-gate.result == 'skipped' && 'â­ï¸ SKIPPED' || 'âŒ FAILED' }}
        - **Build & Push:** ${{ needs.build-and-push.result == 'success' && 'âœ… SUCCESS' || 'âŒ FAILED' }}
        - **Deployment:** ${{ needs.deploy.result == 'success' && 'âœ… SUCCESS' || 'âŒ FAILED' }}
        
        ## ðŸ”— Resources
        - **Application URL:** ${{ needs.deploy.outputs.deployment-url || 'Not available' }}
        - **Images Built:** ${{ needs.build-and-push.outputs.images-built || 'None' }}
        
        ---
        *Deployment completed via GitHub Actions*
        EOF
        
        echo "ðŸ“Š Deployment Summary:"
        cat deployment-summary.md

    - name: ðŸ“¤ Upload Deployment Summary
      uses: actions/upload-artifact@v4
      with:
        name: deployment-summary-${{ github.run_number }}
        path: deployment-summary.md
        retention-days: 90

    - name: ðŸ”” Send Slack Notification
      if: secrets.SLACK_WEBHOOK != ''
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ needs.deploy.result == 'success' && 'success' || 'failure' }}
        text: |
          ðŸš€ **Deployment to ${{ needs.determine-environment.outputs.environment }} completed!**
          
          **Branch:** ${{ github.ref_name }}
          **Environment:** ${{ needs.determine-environment.outputs.environment }}
          **Status:** ${{ needs.deploy.result == 'success' && 'âœ… Success' || 'âŒ Failed' }}
          **URL:** ${{ needs.deploy.outputs.deployment-url || 'Not available' }}
          **Triggered by:** ${{ github.actor }}
          
          **Pipeline Results:**
          â€¢ Security Gate: ${{ needs.security-gate.result == 'success' && 'âœ…' || needs.security-gate.result == 'skipped' && 'â­ï¸' || 'âŒ' }}
          â€¢ Build & Push: ${{ needs.build-and-push.result == 'success' && 'âœ…' || 'âŒ' }}
          â€¢ Deployment: ${{ needs.deploy.result == 'success' && 'âœ…' || 'âŒ' }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}