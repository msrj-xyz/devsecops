name: ğŸš€ Deploy to Google Cloud

on:
  pull_request:
    types: [closed]
    branches: [staging, master]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force-deploy:
        description: 'Force deploy (skip security gate)'
        required: false
        default: false
        type: boolean
      auto-destroy:
        description: 'Enable auto-destroy after 5 minutes (non-production only)'
        required: false
        default: true
        type: boolean

# Prevent concurrent deployments to the same environment
concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'
  GCP_REGION: 'us-central1'
  ARTIFACT_REGISTRY: 'sb-repository'
  GKE_CLUSTER: 'sb-cluster'

jobs:
  # ================================================
  # DETERMINE DEPLOYMENT ENVIRONMENT
  # ================================================
  determine-environment:
    name: ğŸ¯ Determine Environment
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-deploy: ${{ steps.env.outputs.should-deploy }}
      security-gate-required: ${{ steps.env.outputs.security-gate-required }}
      
    steps:
    - name: ğŸ¯ Determine Target Environment
      id: env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          ENVIRONMENT="${{ inputs.environment }}"
          SHOULD_DEPLOY="true"
        else
          case "${{ github.base_ref }}" in
            "staging")
              ENVIRONMENT="staging"
              SHOULD_DEPLOY="true"
              ;;
            "main")
              ENVIRONMENT="production"
              SHOULD_DEPLOY="true"
              ;;
            *)
              ENVIRONMENT="development"
              SHOULD_DEPLOY="false"
              ;;
          esac
        fi
        
        # Determine if security gate is required
        if [ "$ENVIRONMENT" = "production" ] && [ "${{ inputs.force-deploy }}" != "true" ]; then
          SECURITY_GATE_REQUIRED="true"
        else
          SECURITY_GATE_REQUIRED="false"
        fi
        
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        echo "security-gate-required=$SECURITY_GATE_REQUIRED" >> $GITHUB_OUTPUT
        
        echo "ğŸ¯ Environment Configuration:"
        echo "  Environment: $ENVIRONMENT"
        echo "  Should Deploy: $SHOULD_DEPLOY"
        echo "  Security Gate Required: $SECURITY_GATE_REQUIRED"

  # ================================================
  # SECURITY GATE CHECK
  # ================================================
  security-gate:
    name: ğŸ›¡ï¸ Security Gate Check
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.should-deploy == 'true' && needs.determine-environment.outputs.security-gate-required == 'true'
    outputs:
      security-passed: ${{ steps.check.outputs.security-passed }}
      
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Check Latest Security Scan
      id: check
      run: |
        # Get the latest security scan workflow run
        LATEST_RUN=$(gh run list --workflow="security-scan.yml" --branch="${{ github.ref_name }}" --limit=1 --json status,conclusion,createdAt --jq '.[0]')
        
        if [ "$LATEST_RUN" = "null" ] || [ -z "$LATEST_RUN" ]; then
          echo "âŒ No security scan found for this branch"
          echo "security-passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        STATUS=$(echo "$LATEST_RUN" | jq -r '.status')
        CONCLUSION=$(echo "$LATEST_RUN" | jq -r '.conclusion')
        CREATED_AT=$(echo "$LATEST_RUN" | jq -r '.createdAt')
        
        echo "ğŸ“Š Latest Security Scan:"
        echo "  Status: $STATUS"
        echo "  Conclusion: $CONCLUSION"
        echo "  Created: $CREATED_AT"
        
        # Check if security scan passed
        if [ "$STATUS" = "completed" ] && [ "$CONCLUSION" = "success" ]; then
          echo "âœ… Security gate passed"
          echo "security-passed=true" >> $GITHUB_OUTPUT
        else
          echo "âŒ Security gate failed - Status: $STATUS, Conclusion: $CONCLUSION"
          echo "security-passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ================================================
  # BUILD AND PUSH IMAGES
  # ================================================
  build-and-push:
    name: ğŸ—ï¸ Build & Push Images
    runs-on: ubuntu-latest
    needs: [determine-environment, security-gate]
    if: always() && needs.determine-environment.outputs.should-deploy == 'true' && (needs.security-gate.result == 'success' || needs.security-gate.result == 'skipped')
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      images-built: ${{ steps.build.outputs.images-built }}
      
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸŸ¨ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: ğŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ğŸ“¦ Install Dependencies
      run: |
        # Install Node.js dependencies
        if [ -f "package.json" ]; then
          npm ci
        fi
        
        # Install Python dependencies
        if [ -f "requirements.txt" ]; then
          pip install -r requirements.txt
        fi

    - name: ğŸ§ª Run Tests
      run: |
        echo "ğŸ§ª Running tests before deployment..."
        
        # Run Node.js tests
        if [ -f "package.json" ] && npm run test --dry-run 2>/dev/null; then
          npm run test
        fi
        
        # Run Python tests
        if [ -f "requirements.txt" ] && command -v pytest >/dev/null 2>&1; then
          pytest || true
        fi

    - name: ğŸ” Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GOOGLE_CREDENTIALS }}
        project_id: ${{ vars.GCP_PROJECT_ID }}

    - name: ğŸ³ Configure Docker for GCR
      run: |
        gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

    - name: ğŸ—ï¸ Build and Push Container Images
      id: build
      run: |
        IMAGES_BUILT=""
        
        # Find all Dockerfiles and build images
        for dockerfile in $(find . -name "Dockerfile*" -not -path "./.git/*"); do
          dir=$(dirname "$dockerfile")
          project_name=$(basename "$dir")
          
          # Skip if directory name starts with '.'
          if [[ "$project_name" == .* ]]; then
            continue
          fi
          
          echo "ğŸ—ï¸ Building image for: $project_name"
          
          # Determine image tag
          if [ "${{ needs.determine-environment.outputs.environment }}" = "production" ]; then
            IMAGE_TAG="latest"
          else
            IMAGE_TAG="${{ needs.determine-environment.outputs.environment }}"
          fi
          
          IMAGE_NAME="${{ env.GCP_REGION }}-docker.pkg.dev/${{ vars.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/$project_name:$IMAGE_TAG"
          
          # Build image
          docker build -t "$IMAGE_NAME" "$dir"
          
          # Push image
          docker push "$IMAGE_NAME"
          
          echo "âœ… Image pushed: $IMAGE_NAME" 
          IMAGES_BUILT="${IMAGES_BUILT}${project_name}:$IMAGE_TAG,"
        done
        
        # Remove trailing comma
        IMAGES_BUILT=$(echo "$IMAGES_BUILT" | sed 's/,$//')
        echo "images-built=$IMAGES_BUILT" >> $GITHUB_OUTPUT
        
        echo "ğŸ“¦ Images built and pushed:"
        echo "$IMAGES_BUILT" | tr ',' '\n' | sed 's/^/  - /'

  # ================================================
  # DEPLOY TO GOOGLE CLOUD
  # ================================================
  deploy:
    name: ğŸš€ Deploy to GCP
    runs-on: ubuntu-latest
    needs: [determine-environment, security-gate, build-and-push]
    if: always() && needs.build-and-push.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      deployment-url: ${{ steps.deploy.outputs.deployment-url }}
      deployment-status: ${{ steps.deploy.outputs.deployment-status }}
      
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GOOGLE_CREDENTIALS }}
        project_id: ${{ vars.GCP_PROJECT_ID }}

    - name: â˜¸ï¸ Setup GKE kubectl
      uses: google-github-actions/get-gke-credentials@v2
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GCP_REGION }}
        project_id: ${{ vars.GCP_PROJECT_ID }}

    - name: ğŸ“‹ Update Kubernetes Manifests
      run: |
        ENV="${{ needs.determine-environment.outputs.environment }}"
        
        # Create namespace if it doesn't exist
        kubectl create namespace "$ENV" --dry-run=client -o yaml | kubectl apply -f -
        
        # Update Kubernetes manifests with environment-specific values
        if [ -d "k8s/$ENV" ]; then
          echo "ğŸ“‹ Updating manifests for environment: $ENV"
          
          # Replace placeholders in Kubernetes manifests
          find "k8s/$ENV" -name "*.yaml" -o -name "*.yml" | while read -r file; do
            echo "ğŸ“ Processing: $file"
            
            # Replace common placeholders
            sed -i "s/{{ENVIRONMENT}}/$ENV/g" "$file"
            sed -i "s/{{GCP_PROJECT_ID}}/${{ vars.GCP_PROJECT_ID }}/g" "$file"
            sed -i "s/{{GCP_REGION}}/${{ env.GCP_REGION }}/g" "$file"
            sed -i "s/{{ARTIFACT_REGISTRY}}/${{ env.ARTIFACT_REGISTRY }}/g" "$file"
            
            # Set image tags based on environment
            if [ "$ENV" = "production" ]; then
              sed -i "s/{{IMAGE_TAG}}/latest/g" "$file"
            else
              sed -i "s/{{IMAGE_TAG}}/$ENV/g" "$file"
            fi
            
            # Set resource limits based on environment
            case "$ENV" in
              "staging")
                sed -i "s/{{CPU_LIMIT}}/500m/g" "$file"
                sed -i "s/{{MEMORY_LIMIT}}/512Mi/g" "$file"
                sed -i "s/{{REPLICAS}}/2/g" "$file"
                ;;
              "production")
                sed -i "s/{{CPU_LIMIT}}/1000m/g" "$file"
                sed -i "s/{{MEMORY_LIMIT}}/1Gi/g" "$file"
                sed -i "s/{{REPLICAS}}/3/g" "$file"
                ;;
            esac
          done
        else
          echo "âš ï¸ No Kubernetes manifests found for environment: $ENV"
          echo "Creating basic deployment manifest..."
          
          mkdir -p "k8s/$ENV"
          cat > "k8s/$ENV/deployment.yaml" << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: devsecops-app
          namespace: $ENV
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: devsecops-app
          template:
            metadata:
              labels:
                app: devsecops-app
            spec:
              containers:
              - name: app
                image: ${{ env.GCP_REGION }}-docker.pkg.dev/${{ vars.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/react-app:$ENV
                ports:
                - containerPort: 3000
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: devsecops-service
          namespace: $ENV
        spec:
          selector:
            app: devsecops-app
          ports:
          - port: 80
            targetPort: 3000
          type: LoadBalancer
        EOF
        fi

    - name: ğŸš€ Deploy to Kubernetes
      id: deploy
      run: |
        ENV="${{ needs.determine-environment.outputs.environment }}"
        
        echo "ğŸš€ Deploying to environment: $ENV"
        
        # Apply Kubernetes manifests
        if [ -d "k8s/$ENV" ]; then
          kubectl apply -f "k8s/$ENV/" --recursive
          
          # Wait for deployment to be ready
          echo "â³ Waiting for deployment to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment --all -n "$ENV"
          
          # Get service external IP
          echo "ğŸŒ Getting service external IP..."
          EXTERNAL_IP=""
          for i in {1..10}; do
            EXTERNAL_IP=$(kubectl get service -n "$ENV" -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
              break
            fi
            echo "  Waiting for external IP... (attempt $i/10)"
            sleep 30
          done
          
          if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
            DEPLOYMENT_URL="http://$EXTERNAL_IP"
            echo "âœ… Deployment successful!"
            echo "ğŸŒ Application URL: $DEPLOYMENT_URL"
            echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
            echo "deployment-status=success" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Deployment completed but external IP not available yet"
            echo "deployment-url=pending" >> $GITHUB_OUTPUT
            echo "deployment-status=pending" >> $GITHUB_OUTPUT
          fi
          
          # Show deployment status
          echo "ğŸ“Š Deployment Status:"
          kubectl get pods,services,deployments -n "$ENV"
          
        else
          echo "âŒ No Kubernetes manifests found to deploy"
          echo "deployment-status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: ğŸ§ª Post-Deployment Health Check
      if: steps.deploy.outputs.deployment-url != 'pending'
      run: |
        DEPLOYMENT_URL="${{ steps.deploy.outputs.deployment-url }}"
        
        if [ "$DEPLOYMENT_URL" != "pending" ] && [ -n "$DEPLOYMENT_URL" ]; then
          echo "ğŸ” Running health check on: $DEPLOYMENT_URL"
          
          # Wait a bit for the application to fully start
          sleep 30
          
          # Simple health check
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOYMENT_URL" || echo "000")
          
          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
            echo "âœ… Health check passed - HTTP $HTTP_STATUS"
          else
            echo "âš ï¸ Health check warning - HTTP $HTTP_STATUS"
            echo "Application may still be starting up..."
          fi
        else
          echo "â­ï¸ Skipping health check - URL not available yet"
        fi

  # ================================================
  # DEPLOYMENT SUMMARY & NOTIFICATION
  # ================================================
  notify:
    name: ğŸ”” Deployment Notification
    runs-on: ubuntu-latest
    needs: [determine-environment, security-gate, build-and-push, deploy]
    if: always() && needs.determine-environment.outputs.should-deploy == 'true'
    
    steps:
    - name: ğŸ“Š Generate Deployment Summary
      run: |
        cat > deployment-summary.md << 'EOF'
        # ğŸš€ Deployment Summary
        
        **Environment:** ${{ needs.determine-environment.outputs.environment }}
        **Branch:** ${{ github.ref_name }}
        **Commit:** ${{ github.sha }}
        **Triggered by:** ${{ github.actor }}
        **Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
        
        ## ğŸ“Š Results
        - **Security Gate:** ${{ needs.security-gate.result == 'success' && 'âœ… PASSED' || needs.security-gate.result == 'skipped' && 'â­ï¸ SKIPPED' || 'âŒ FAILED' }}
        - **Build & Push:** ${{ needs.build-and-push.result == 'success' && 'âœ… SUCCESS' || 'âŒ FAILED' }}
        - **Deployment:** ${{ needs.deploy.result == 'success' && 'âœ… SUCCESS' || 'âŒ FAILED' }}
        
        ## ğŸ”— Resources
        - **Application URL:** ${{ needs.deploy.outputs.deployment-url || 'Not available' }}
        - **Images Built:** ${{ needs.build-and-push.outputs.images-built || 'None' }}
        
        ---
        *Deployment completed via GitHub Actions*
        EOF
        
        echo "ğŸ“Š Deployment Summary:"
        cat deployment-summary.md

    - name: ğŸ“¤ Upload Deployment Summary
      uses: actions/upload-artifact@v4
      with:
        name: deployment-summary-${{ github.run_number }}
        path: deployment-summary.md
        retention-days: 90

    - name: ğŸ”” Send Slack Notification
      continue-on-error: true
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ needs.deploy.result == 'success' && 'success' || 'failure' }}
        text: |
          ğŸš€ **Deployment to ${{ needs.determine-environment.outputs.environment }} completed!**
          
          **Branch:** ${{ github.ref_name }}
          **Environment:** ${{ needs.determine-environment.outputs.environment }}
          **Status:** ${{ needs.deploy.result == 'success' && 'âœ… Success' || 'âŒ Failed' }}
          **URL:** ${{ needs.deploy.outputs.deployment-url || 'Not available' }}
          **Triggered by:** ${{ github.actor }}
          
          **Pipeline Results:**
          â€¢ Security Gate: ${{ needs.security-gate.result == 'success' && 'âœ…' || needs.security-gate.result == 'skipped' && 'â­ï¸' || 'âŒ' }}
          â€¢ Build & Push: ${{ needs.build-and-push.result == 'success' && 'âœ…' || 'âŒ' }}
          â€¢ Deployment: ${{ needs.deploy.result == 'success' && 'âœ…' || 'âŒ' }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  # ================================================
  # AUTO-DESTROY AFTER 5 MINUTES
  # ================================================
  auto-destroy:
    name: ğŸ—‘ï¸ Auto-Destroy Resources
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy]
    if: always() && needs.deploy.result == 'success' && needs.determine-environment.outputs.environment != 'production' && (github.event.inputs.auto-destroy == 'true' || github.event.inputs.auto-destroy == null)
    environment: ${{ needs.determine-environment.outputs.environment }}
    
    steps:
    - name: â±ï¸ Wait 5 Minutes
      run: |
        echo "ğŸ• Starting 5-minute countdown before resource cleanup..."
        echo "âš ï¸  Resources will be destroyed automatically to save costs"
        echo "ğŸš« To prevent destruction, cancel this workflow within 5 minutes"
        
        for i in {300..1}; do
          mins=$((i / 60))
          secs=$((i % 60))
          printf "\râ³ Destroying in: %02d:%02d" "$mins" "$secs"
          sleep 1
        done
        
        echo ""
        echo "ğŸ—‘ï¸ Time's up! Proceeding with resource cleanup..."

    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GOOGLE_CREDENTIALS }}
        project_id: ${{ vars.GCP_PROJECT_ID }}

    - name: â˜¸ï¸ Setup GKE kubectl
      uses: google-github-actions/get-gke-credentials@v2
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GCP_REGION }}
        project_id: ${{ vars.GCP_PROJECT_ID }}

    - name: ğŸ—‘ï¸ Destroy Kubernetes Resources
      run: |
        ENV="${{ needs.determine-environment.outputs.environment }}"
        
        echo "ğŸ§¹ Cleaning up resources in namespace: $ENV"
        
        # Delete all deployments in the namespace
        echo "ğŸ—‘ï¸ Deleting deployments..."
        kubectl delete deployments --all -n "$ENV" --ignore-not-found=true
        
        # Delete all services in the namespace
        echo "ğŸ—‘ï¸ Deleting services..."
        kubectl delete services --all -n "$ENV" --ignore-not-found=true
        
        # Delete all ingresses in the namespace
        echo "ğŸ—‘ï¸ Deleting ingresses..."
        kubectl delete ingresses --all -n "$ENV" --ignore-not-found=true
        
        # Delete all configmaps (except system ones)
        echo "ğŸ—‘ï¸ Deleting configmaps..."
        kubectl delete configmaps --all -n "$ENV" --ignore-not-found=true
        
        # Delete all secrets (except system ones)
        echo "ğŸ—‘ï¸ Deleting secrets..."
        kubectl delete secrets --field-selector type!=kubernetes.io/service-account-token -n "$ENV" --ignore-not-found=true
        
        echo "âœ… Kubernetes resources cleanup completed"

    - name: ğŸ³ Clean Docker Images
      run: |
        ENV="${{ needs.determine-environment.outputs.environment }}"
        
        echo "ğŸ§¹ Cleaning up container images for environment: $ENV"
        
        # List and delete images for this environment
        IMAGES=$(gcloud artifacts docker images list \
          ${{ env.GCP_REGION }}-docker.pkg.dev/${{ vars.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }} \
          --filter="tags:$ENV" \
          --format="value(IMAGE)" \
          --limit=50 2>/dev/null || true)
        
        if [ ! -z "$IMAGES" ]; then
          echo "ğŸ—‘ï¸ Deleting container images:"
          echo "$IMAGES"
          echo "$IMAGES" | xargs -I {} gcloud artifacts docker images delete {} --delete-tags --quiet || true
          echo "âœ… Container images cleanup completed"
        else
          echo "â„¹ï¸ No container images found for environment: $ENV"
        fi

    - name: ğŸ“Š Cleanup Summary
      run: |
        ENV="${{ needs.determine-environment.outputs.environment }}"
        
        echo "ğŸ“‹ Auto-Destroy Summary:"
        echo "=============================="
        echo "ğŸ¯ Environment: $ENV"
        echo "â° Destruction Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "ğŸ‘¤ Triggered by: ${{ github.actor }}"
        echo "ğŸ”— Workflow: ${{ github.repository }}/actions/runs/${{ github.run_id }}"
        echo ""
        echo "âœ… Resources Successfully Destroyed:"
        echo "  â€¢ Kubernetes Deployments"
        echo "  â€¢ Kubernetes Services"
        echo "  â€¢ Kubernetes Ingresses"
        echo "  â€¢ Kubernetes ConfigMaps"
        echo "  â€¢ Kubernetes Secrets"
        echo "  â€¢ Container Images (tagged: $ENV)"
        echo ""
        echo "ğŸ’° Cost Savings: Resources automatically cleaned up after 5 minutes"
        echo "ğŸ”„ Next Deployment: Will recreate all resources from scratch"

  # ================================================
  # NOTIFY AUTO-DESTROY
  # ================================================
  notify-destroy:
    name: ğŸ“¢ Notify Auto-Destroy
    runs-on: ubuntu-latest
    needs: [determine-environment, auto-destroy]
    if: always() && needs.auto-destroy.result != 'skipped'
    
    steps:
    - name: ğŸ“¢ Notify Slack - Auto-Destroy
      continue-on-error: true
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ needs.auto-destroy.result == 'success' && 'success' || 'failure' }}
        channel: '#devops'
        username: 'GitHub Actions'
        icon_emoji: ':boom:'
        fields: |
          {
            "title": "${{ needs.auto-destroy.result == 'success' && 'ğŸ—‘ï¸ Auto-Destroy Completed' || 'âŒ Auto-Destroy Failed' }}",
            "value": "Environment: ${{ needs.determine-environment.outputs.environment }}\nStatus: ${{ needs.auto-destroy.result == 'success' && 'âœ… Resources Destroyed' || 'âŒ Cleanup Failed' }}",
            "short": false
          }
        text: |
          **Repository:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Environment:** ${{ needs.determine-environment.outputs.environment }}
          **Status:** ${{ needs.auto-destroy.result == 'success' && 'âœ… Resources Destroyed' || 'âŒ Cleanup Failed' }}
          **Triggered by:** ${{ github.actor }}
          **Duration:** 5 minutes post-deployment
          
          ${{ needs.auto-destroy.result == 'success' && 'ğŸ’° **Cost Savings:** All cloud resources have been automatically cleaned up' || 'âš ï¸ **Action Required:** Manual cleanup may be needed' }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}